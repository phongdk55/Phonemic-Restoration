import theano
from theano import tensor as T
import numpy as np
from load_data_DNN import read_features, read_file_test
import math
import os,re
import logging
from weight_matrix_b import save_weight_info, load_weight_info, load_initial_info

class DNN_net():
    def __init__(self):        
        self.hidden_layer = '5_layers/'       # = n_hidden layer below
        self.artic = 'artic/'             # type of testing audio - noise or space / type of whether using articulatory data or not
        self.test_number = 0
        self._load_parameters()
        self._training_DNN()
        
    def sgd(self,cost, params, bias, lr=0.05):             # generalize to compute gradient descent
        updates = []
        
        grads = T.grad(cost=cost, wrt=params)   # on all model parameters
        for p, g in zip(params, grads):
            updates.append([p, p - g * lr])
         
        grads = T.grad(cost=cost,wrt=bias)
        for p, g in zip(bias, grads):
            updates.append([p, p - g * lr])
        
        return updates
    
    def model(self,X, params, bias):            # bias kich thuoc 1 * m, chi chay duoc voi tung frame, ko chay duoc vs nhieu frame 1 luc
        for u in xrange(len(params) - 1):
            h = T.tanh(T.dot(X, params[u]) + bias[u])    # use tanh function
            X = h
        pyx = T.dot(X, params[len(params) - 1]) + bias[len(params)-1]     # hidden -> output   
        
        return pyx           
   
    def _load_parameters(self):   
        load_params = False
        
        self.id_file = 1
        self.weight_folder = '../weight_DNN/SQR/' + self.hidden_layer + self.artic + 'test_' + str(self.test_number) + '/'
        
        if not os.path.exists(self.weight_folder):
            os.makedirs(self.weight_folder)
            
        self.filename = self.weight_folder + 'Phonemic_DNN_SGD_id_' + str(self.id_file) + ".txt"
        
        if load_params:
            self.nloop,self.n_hidden_layer, self.n_input_f, self.n_hidden_f, self.n_output_f, self.params, self.bias= load_weight_info(self.filename)             
        else:
            self.nloop = 0
            self.n_hidden_layer = 1
            self.n_input_f = 20
            self.n_hidden_f = 100
            self.n_output_f = 15
            self.params, self.bias = load_initial_info(self.n_hidden_layer, self.n_input_f, self.n_hidden_f, self.n_output_f)
        
    def _training_DNN(self):   
        trX, trY, self.missing_filename_list,  = read_features(self.test_number, self.n_input_f, self.n_output_f)     
        trX = trX[:,1:self.n_input_f]
        trY = trY[:,1:self.n_output_f]
        print trX.shape
        print trY.shape   
        print self.nloop, self.n_hidden_layer, self.n_input_f, self.n_hidden_f, self.n_output_f
        
        X = T.fmatrix()
        Y = T.fmatrix()
        py_x = self.model(X, self.params, self.bias)
        y_x = py_x
        #cost = T.mean(T.nnet.categorical_crossentropy(py_x, Y))
        cost = T.mean(T.sqr(py_x - Y))
        #params = [w_h, w_h1, w_h2, w_h3, w_o]
        updates = self.sgd(cost, self.params, self.bias)
        train = theano.function(inputs=[X, Y], outputs=cost, updates=updates, allow_input_downcast=True)
        self.predict = theano.function(inputs=[X], outputs=y_x, allow_input_downcast=True)
        #LOG_FILENAME = 'DNN.log'
        #logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG)
              
        for i in range(self.nloop, self.nloop + 10 ):
            print i
            #logging.debug('loop' + str(i))
            error_total = 0
            arr_X_Y = zip(range(0, len(trX), 128), range(128, len(trX), 128))
            for start, end in arr_X_Y:
                cost = train(trX[start:end], trY[start:end])
                error_total += cost
                #print cost
            last_element = arr_X_Y[len(arr_X_Y)-1][0] 
            if last_element < len(trX):
                cost = train(trX[last_element: len(trX)], trY[last_element:len(trY)])    
                error_total += cost
            print error_total / len(trX)
            save_weight_info( self.filename, i, self.n_hidden_layer, self.n_input_f, self.n_hidden_f, self.n_output_f, self.params, error_total, self.bias)
            self.id_file = 1 - self.id_file
            self.filename = self.weight_folder + 'Phonemic_DNN_SGD_id_' + str(self.id_file) + ".txt"

a = DNN_net()
#Phonemic_DNN = Deep_Neural_Network()